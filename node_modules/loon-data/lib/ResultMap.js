"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const _ = require("lodash");
function isBlank(data) {
    return _.isUndefined(data) || _.isNull(data) || _.isEmpty(data) || _.isNaN(data);
}
class Wrapper {
    constructor(data, currentIndex) {
        this.data = data;
        this.indexList = [currentIndex];
    }
}
const handleMap = (data, map, isCollection) => {
    if (isBlank(data) || isBlank(map) || isBlank(map.results)) {
        return;
    }
    const results = map.results;
    if (isBlank(results)) {
        return;
    }
    if (!_.isArray(data)) {
        data = [data];
    }
    const insList = data.map(item => {
        const type = map.type;
        const ins = new type();
        Object.keys(item).forEach(column => {
            const resultMap = results.find(result => {
                const resultColumn = result.column ? result.column : result.property;
                return resultColumn === column;
            });
            if (resultMap) {
                const property = resultMap.property ? resultMap.property : column;
                ins[property] = item[column];
            }
        });
        return ins;
    });
    const uniqueInsList = [];
    insList.forEach((ins, index) => {
        if (isBlank(ins)) {
            return;
        }
        if (!Object.keys(ins).some(key => !_.isUndefined(ins[key]) || !_.isNull(ins[key]))) {
            return;
        }
        const uniqueResult = uniqueInsList.some(uniqueIns => {
            if (_.isEqual(ins, uniqueIns.data)) {
                uniqueIns.indexList.push(index);
                return true;
            }
            return false;
        });
        if (uniqueResult) {
            return;
        }
        const wrapper = new Wrapper(ins, index);
        uniqueInsList.push(wrapper);
    });
    if (isBlank(uniqueInsList)) {
        return;
    }
    uniqueInsList.forEach(wrapper => {
        const associations = map.associations;
        if (associations) {
            associations.map(association => {
                const associationIns = handleMap(data[wrapper.indexList[0]], association, false);
                wrapper.data[association.property] = associationIns;
            });
        }
        const collections = map.collections;
        if (collections) {
            collections.forEach(collection => {
                const collectionData = wrapper.indexList.map(index => data[index]);
                const collectionInsList = handleMap(collectionData, collection, true);
                wrapper.data[collection.property] = collectionInsList;
            });
        }
    });
    if (isCollection) {
        return uniqueInsList.map(_ => _.data);
    }
    else {
        return uniqueInsList[0].data;
    }
};
function ResultMapping(map) {
    return (target, key, descriptor) => {
        const method = descriptor.value;
        descriptor.value = (...args) => __awaiter(this, void 0, void 0, function* () {
            const data = yield method.apply(target, args);
            return handleMap(data, map, false);
        });
    };
}
exports.ResultMapping = ResultMapping;
function ResultsMapping(map) {
    return (target, key, descriptor) => {
        const method = descriptor.value;
        descriptor.value = (...args) => __awaiter(this, void 0, void 0, function* () {
            const data = yield method.apply(target, args);
            return handleMap(data, map, true);
        });
    };
}
exports.ResultsMapping = ResultsMapping;
//# sourceMappingURL=ResultMap.js.map