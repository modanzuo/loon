"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ParamType_1 = require("./enum/ParamType");
const DependencyRegistry_1 = require("../di/DependencyRegistry");
const _ = require("lodash");
const ParamRequired_1 = require("./error/ParamRequired");
const ConverterService_1 = require("../converter/ConverterService");
/**
 * Transform a handler to a express handler
 *
 * Support required param check, and param convert for PathParam, BodyParam, QueryParam
 *
 */
class HandlerTransformer {
    get handlerMetadata() {
        return this._handlerMetadata;
    }
    constructor(handlerMetadata) {
        this._handlerMetadata = handlerMetadata;
    }
    transform() {
        const isErrorHandler = this.handlerMetadata.isErrorHandler;
        if (isErrorHandler) {
            return (err, req, res, next) => {
                return Promise
                    .resolve()
                    .then(() => this.invokeMethod(req, res, next, err))
                    .catch(err => next(err));
            };
        }
        else {
            return (req, res, next) => {
                return Promise
                    .resolve()
                    .then(() => this.invokeMethod(req, res, next))
                    .catch(err => next(err));
            };
        }
    }
    invokeMethod(request, response, next, error) {
        if (response.headersSent) {
            return;
        }
        const methodName = this.handlerMetadata.actionName;
        const args = [];
        const converter = DependencyRegistry_1.DependencyRegistry.get(ConverterService_1.ConverterService);
        this.handlerMetadata.params.forEach(param => {
            switch (param.paramType) {
                case ParamType_1.ParamType.Path:
                    let path = _.get(request.params, param.expression);
                    if (param.required && typeof path === 'undefined') {
                        throw new ParamRequired_1.ParamRequired(param.expression);
                    }
                    path = converter.convert(path, param.returnType);
                    args.push(path);
                    return;
                case ParamType_1.ParamType.Body:
                    let body = _.get(request.body, param.expression);
                    if (param.required && typeof body === 'undefined') {
                        throw new ParamRequired_1.ParamRequired(param.expression);
                    }
                    body = converter.convert(body, param.returnType);
                    args.push(body);
                    return;
                case ParamType_1.ParamType.Query:
                    let query = _.get(request.query, param.expression);
                    if (param.required && typeof query === 'undefined') {
                        throw new ParamRequired_1.ParamRequired(param.expression);
                    }
                    query = converter.convert(query, param.returnType);
                    args.push(query);
                    return;
                case ParamType_1.ParamType.Cookie:
                    const cookie = _.get(request.cookies, param.expression);
                    if (param.required && typeof cookie === 'undefined') {
                        throw new ParamRequired_1.ParamRequired(param.expression);
                    }
                    args.push(cookie);
                    return;
                case ParamType_1.ParamType.Header:
                    const header = request.header(param.expression);
                    if (param.required && typeof header === 'undefined') {
                        throw new ParamRequired_1.ParamRequired(param.expression);
                    }
                    args.push(header);
                    return;
                case ParamType_1.ParamType.Error:
                    args.push(error);
                    return;
                case ParamType_1.ParamType.Request:
                    args.push(request);
                    return;
                case ParamType_1.ParamType.Response:
                    args.push(response);
                    return;
                case ParamType_1.ParamType.Next:
                    args.push(next);
                    return;
                case ParamType_1.ParamType.Data:
                    args.push(response.locals);
                    return;
                default:
                    args.push(undefined);
                    return;
            }
        });
        const handlerKlass = this.handlerMetadata.type;
        const handlerInstance = DependencyRegistry_1.DependencyRegistry.get(handlerKlass);
        return handlerInstance[methodName].apply(handlerInstance, args);
    }
}
exports.HandlerTransformer = HandlerTransformer;
//# sourceMappingURL=HandlerTransformer.js.map