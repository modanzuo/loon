"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const DIException_1 = require("./error/DIException");
class DIContainer {
    static registerComponent(name, type, params) {
        this.components.push({
            name,
            type,
            params
        });
    }
    static registerParamHandler(handler) {
        this.paramHandlers.push(handler);
    }
    static registerPropertyHandler(handler) {
        this.propertyHandlers.push(handler);
    }
    // public static unregisterComponent(actionName: string|undefined, type: Function) {
    //     this.components = this.components.filter(item => item.actionName !== actionName && item.type !== type);
    // }
    //
    // public static set(nameOrType: Function|string, value: any) {
    //
    //     if (this.findInstanceByNameOrType(nameOrType)) {
    //         throw new DIException('[Typed] can not find instance');
    //     }
    //
    //     if (typeof nameOrType === "string") {
    //
    //         this.instances.push({
    //             actionName: nameOrType,
    //             type: undefined,
    //             instance: value
    //         });
    //
    //     } else {
    //
    //         this.instances.push({
    //             actionName: undefined,
    //             type: nameOrType,
    //             instance: value
    //         });
    //     }
    // }
    // public static clear() {
    //     this.instances = [];
    //     this.components = [];
    // }
    static get(nameOrType) {
        let instance = this.findInstanceByNameOrType(nameOrType);
        if (instance) {
            return instance;
        }
        const component = this.findComponentByNameOrType(nameOrType);
        const name = component.name;
        const type = component.type;
        let params = component.params;
        if (params) {
            params = this.initParams(type, params);
            params.unshift(null);
        }
        instance = new (type.bind.apply(type, params))();
        this.instances.push({ name, type, instance });
        this.applyProperties(type);
        return instance;
    }
    static initParams(type, params) {
        return params.map((param, index) => {
            const handler = this.paramHandlers.find(item => item.type === type && item.index === index);
            if (handler) {
                return handler.getValue();
            }
            return DIContainer.get(param);
        });
    }
    static applyProperties(type) {
        this.propertyHandlers
            .filter(handler => handler.type === type)
            .map(item => {
            Object.defineProperty(type.prototype, item.key, {
                configurable: true,
                enumerable: true,
                writable: true,
                value: item.getValue()
            });
        });
    }
    static findInstanceByName(name) {
        const instanceItem = this.instances.find(item => item.name === name);
        if (instanceItem) {
            return instanceItem.instance;
        }
    }
    static findInstanceByType(type) {
        const instanceItem = this.instances.find(item => item.type === type);
        if (instanceItem) {
            return instanceItem.instance;
        }
    }
    static findInstanceByNameOrType(nameOrType) {
        if (typeof nameOrType === 'string') {
            return this.findInstanceByName(nameOrType);
        }
        else {
            return this.findInstanceByType(nameOrType);
        }
    }
    static findComponentByName(name) {
        const component = this.components.find(item => item.name === name);
        if (component) {
            return component;
        }
        else {
            throw new DIException_1.DIException(`[TYPED] can not find component by name ${name}`);
        }
    }
    static findComponentByType(type) {
        const component = this.components.find(item => item.type === type);
        if (component) {
            return component;
        }
        else {
            throw new DIException_1.DIException(`[TYPED] can not find component by type ${type}`);
        }
    }
    static findComponentByNameOrType(nameOrType) {
        if (typeof nameOrType === "string") {
            return this.findComponentByName(nameOrType);
        }
        else {
            return this.findComponentByType(nameOrType);
        }
    }
}
DIContainer.instances = [];
DIContainer.components = [];
DIContainer.paramHandlers = [];
DIContainer.propertyHandlers = [];
exports.DIContainer = DIContainer;
//# sourceMappingURL=DIContainer.js.map